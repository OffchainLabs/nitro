// Copyright 2022-2024, Offchain Labs, Inc.
// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE

use arbutil::{
    benchmark::Benchmark,
    evm::{
        api::{EvmApiMethod, Gas, Ink, VecReader, EVM_API_METHOD_REQ_OFFSET},
        req::{EvmApiRequestor, RequestHandler},
        user::UserOutcomeKind,
        EvmData,
    },
    Color,
};
use caller_env::{static_caller::STATIC_MEM, GuestPtr, MemAccess};
use core::sync::atomic::{compiler_fence, Ordering};
use eyre::{eyre, Result};
use prover::programs::prelude::*;
use std::fmt::Display;
use user_host_trait::UserHost;
use wasmer_types::{Pages, WASM_PAGE_SIZE};

// allows introspection into user modules
#[link(wasm_import_module = "hostio")]
extern "C" {
    fn program_memory_size(module: u32) -> u32;
}

/// Signifies an out-of-bounds memory access was requested.
pub(crate) struct MemoryBoundsError;

impl From<MemoryBoundsError> for eyre::ErrReport {
    fn from(_: MemoryBoundsError) -> Self {
        eyre!("memory access out of bounds")
    }
}

/// The list of active programs. The current program is always the last.
///
/// Note that this data-structure may re-alloc while references to [`Program`] are held.
/// This is sound due to [`Box`] providing a level of indirection.
///
/// Normal Rust rules would suggest using a [`Vec`] of cells would be better. The issue is that,
/// should an error guard recover, this WASM will reset to an earlier state but with the current
/// memory. This means that stack unwinding won't happen, rendering these primitives unhelpful.
#[allow(clippy::vec_box)]
static mut PROGRAMS: Vec<Box<Program>> = vec![];

static mut LAST_REQUEST_ID: u32 = 0x10000;

#[derive(Clone)]
pub(crate) struct UserHostRequester {
    data: Option<Vec<u8>>,
    answer: Option<(Vec<u8>, VecReader, Gas)>,
    req_type: u32,
    id: u32,
}

impl UserHostRequester {
    pub fn default() -> Self {
        Self {
            req_type: 0,
            data: None,
            answer: None,
            id: 0,
        }
    }
}

/// An active user program.
pub(crate) struct Program {
    /// Arguments passed via the VM.
    pub args: Vec<u8>,
    /// Output generated by the program.
    pub outs: Vec<u8>,
    /// Mechanism for calling back into Geth.
    pub evm_api: EvmApiRequestor<VecReader, UserHostRequester>,
    /// EVM Context info.
    pub evm_data: EvmData,
    // Used to benchmark execution blocks of code
    pub benchmark: Benchmark,
    /// WAVM module index.
    pub module: u32,
    /// Call configuration.
    pub config: StylusConfig,
    /// Whether the program exited early.
    pub early_exit: Option<UserOutcomeKind>,
}

#[link(wasm_import_module = "hostio")]
extern "C" {
    fn program_request(status: u32) -> u32;
}

impl UserHostRequester {
    #[no_mangle]
    pub unsafe fn set_response(
        &mut self,
        req_id: u32,
        result: Vec<u8>,
        raw_data: Vec<u8>,
        gas: Gas,
    ) {
        self.answer = Some((result, VecReader::new(raw_data), gas));
        if req_id != self.id {
            panic!("bad req id returning from send_request")
        }
        compiler_fence(Ordering::SeqCst);
    }

    pub unsafe fn set_request(&mut self, req_type: u32, data: &[u8]) -> u32 {
        LAST_REQUEST_ID += 1;
        self.id = LAST_REQUEST_ID;
        self.req_type = req_type;
        self.data = Some(data.to_vec());
        self.answer = None;
        self.id
    }

    pub unsafe fn get_request_meta(&self, id: u32) -> (u32, usize) {
        if self.id != id {
            panic!("get_request got wrong id");
        }
        let size = self.data.as_ref().expect("no data get_request_meta").len();
        (self.req_type, size)
    }

    pub unsafe fn take_request(&mut self, id: u32) -> (u32, Vec<u8>) {
        if self.id != id {
            panic!("get_request got wrong id");
        }
        let data = self.data.take().expect("no request on take_request");
        (self.req_type, data)
    }

    #[no_mangle]
    unsafe fn send_request(&mut self, req_type: u32, data: Vec<u8>) -> (Vec<u8>, VecReader, Gas) {
        let req_id = self.set_request(req_type, &data);
        compiler_fence(Ordering::SeqCst);

        let got_id = program_request(req_id);
        compiler_fence(Ordering::SeqCst);

        if got_id != req_id {
            panic!("bad req id returning from send_request")
        }
        self.answer.take().unwrap()
    }
}

impl RequestHandler<VecReader> for UserHostRequester {
    fn request(
        &mut self,
        req_type: EvmApiMethod,
        req_data: impl AsRef<[u8]>,
    ) -> (Vec<u8>, VecReader, Gas) {
        unsafe {
            self.send_request(
                req_type as u32 + EVM_API_METHOD_REQ_OFFSET,
                req_data.as_ref().to_vec(),
            )
        }
    }
}

impl Program {
    /// Adds a new program, making it current.
    pub fn push_new(args: Vec<u8>, evm_data: EvmData, module: u32, config: StylusConfig) {
        let program = Self {
            args,
            outs: vec![],
            evm_api: EvmApiRequestor::new(UserHostRequester::default()),
            evm_data,
            benchmark: Benchmark::default(),
            module,
            config,
            early_exit: None,
        };
        unsafe { PROGRAMS.push(Box::new(program)) }
    }

    /// Removes the current program
    pub fn pop() {
        unsafe {
            PROGRAMS.pop().expect("no program");
        }
    }

    /// Provides a reference to the current program.
    pub fn current() -> &'static mut Self {
        unsafe { PROGRAMS.last_mut().expect("no program") }
    }

    /// Reads the program's memory size in pages.
    fn memory_size(&self) -> Pages {
        unsafe { Pages(program_memory_size(self.module)) }
    }

    /// Reads the program's memory size in bytes.
    fn memory_size_bytes(&self) -> u64 {
        self.memory_size().0 as u64 * WASM_PAGE_SIZE as u64
    }

    /// Provides the length of the program's calldata in bytes.
    pub fn args_len(&self) -> usize {
        self.args.len()
    }

    /// Ensures an access is within bounds
    fn check_memory_access(&self, ptr: GuestPtr, bytes: u32) -> Result<(), MemoryBoundsError> {
        let end = ptr.to_u64() + bytes as u64;
        if end > self.memory_size_bytes() {
            return Err(MemoryBoundsError);
        }
        Ok(())
    }

    pub fn request_handler(&mut self) -> &mut UserHostRequester {
        self.evm_api.request_handler()
    }
}

#[allow(clippy::unit_arg)]
impl UserHost<VecReader> for Program {
    type Err = eyre::ErrReport;
    type MemoryErr = MemoryBoundsError;
    type A = EvmApiRequestor<VecReader, UserHostRequester>;

    fn args(&self) -> &[u8] {
        &self.args
    }

    fn outs(&mut self) -> &mut Vec<u8> {
        &mut self.outs
    }

    fn evm_api(&mut self) -> &mut Self::A {
        &mut self.evm_api
    }

    fn evm_data(&self) -> &EvmData {
        &self.evm_data
    }

    fn benchmark(&mut self) -> &mut Benchmark {
        &mut self.benchmark
    }

    fn evm_return_data_len(&mut self) -> &mut u32 {
        &mut self.evm_data.return_data_len
    }

    fn read_slice(&self, ptr: GuestPtr, len: u32) -> Result<Vec<u8>, MemoryBoundsError> {
        self.check_memory_access(ptr, len)?;
        unsafe { Ok(STATIC_MEM.read_slice(ptr, len as usize)) }
    }

    fn read_fixed<const N: usize>(&self, ptr: GuestPtr) -> Result<[u8; N], MemoryBoundsError> {
        self.read_slice(ptr, N as u32)
            .map(|x| x.try_into().unwrap())
    }

    fn write_u32(&mut self, ptr: GuestPtr, x: u32) -> Result<(), MemoryBoundsError> {
        self.check_memory_access(ptr, 4)?;
        unsafe { Ok(STATIC_MEM.write_u32(ptr, x)) }
    }

    fn write_slice(&self, ptr: GuestPtr, src: &[u8]) -> Result<(), MemoryBoundsError> {
        self.check_memory_access(ptr, src.len() as u32)?;
        unsafe { Ok(STATIC_MEM.write_slice(ptr, src)) }
    }

    fn say<D: Display>(&self, text: D) {
        println!("{} {text}", "Stylus says:".yellow());
    }

    fn trace(&mut self, name: &str, args: &[u8], outs: &[u8], _end_ink: Ink) {
        let args = hex::encode(args);
        let outs = hex::encode(outs);
        println!("Error: unexpected hostio tracing info for {name} while proving: {args}, {outs}");
    }
}
