package generate

import (
	"context"
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/offchainlabs/nitro/arbnode"
	"github.com/offchainlabs/nitro/arbos/arbostypes"
	"github.com/offchainlabs/nitro/arbutil"
	"github.com/offchainlabs/nitro/execution"
	execution_engine "github.com/offchainlabs/nitro/system_tests/espresso/execution_engine"
)

// Message is a struct that holds the generated message data that
// is needed for the TransactionStreamer to process messages.
type Message struct {
	pos           arbutil.MessageIndex
	msgWithMeta   arbostypes.MessageWithMetadata
	msgResult     execution.MessageResult
	blockMetadata common.BlockMetadata
}

// MessageGenerator is an interface that provides a simple way to generate
// random messages for testing purposes.
type MessageGenerator interface {
	GenerateMessage(arbutil.MessageIndex) Message
}

// simpleGenerator is a struct that implements the MessageGenerator
// interface in a very simple way.
//
// It is able to generate messages with a fixed size and a random payload.
// The size of the messages can be configured when creating the generator.
type simpleGenerator struct {
	hasher execution_engine.MessageHasher
	size   int
}

// This is a compile time assertion to ensure that simpleGenerator
// implements MessageGenerator.
var _ MessageGenerator = simpleGenerator{}

// SimpleGeneratorConfig is a struct that holds the configuration for
// creating a simpleGenerator. It includes the hasher and the size of the
// messages to be generated.
type SimpleGeneratorConfig struct {
	Hasher execution_engine.MessageHasher
	Size   int
}

// SimpleGeneratorOption is a function that modifies the SimpleGeneratorConfig
// to allow for flexible configuration of the NewSimpleGenerator function
// without hardcoding values in the generator implementation.
type SimpleGeneratorOption func(*SimpleGeneratorConfig)

// WithHasher sets the hasher for the SimpleGeneratorConfig.
func WithHasher(hasher execution_engine.MessageHasher) SimpleGeneratorOption {
	return func(config *SimpleGeneratorConfig) {
		config.Hasher = hasher
	}
}

// WithSize sets the size of the messages to be generated in the
// SimpleGeneratorConfig.
func WithSize(size int) SimpleGeneratorOption {
	return func(config *SimpleGeneratorConfig) {
		config.Size = size
	}
}

// DefaultMoltenMessageSize is the default size of the messages generated by
// the MessageGenerator.
//
// This sized is based on the average size of the messages observed in Molten
const DefaultMoltenMessageSize = 3 * 1024 // 3 KiB

// NewSimpleGenerator creates a new instance of simpleGenerator.
// It takes a hasher and a size as parameters.
func NewSimpleGenerator(options ...SimpleGeneratorOption) MessageGenerator {
	config := SimpleGeneratorConfig{
		Hasher: execution_engine.DefaultMessageHasher,
		Size:   DefaultMoltenMessageSize,
	}

	for _, option := range options {
		option(&config)
	}

	return simpleGenerator{
		hasher: config.Hasher,
		size:   config.Size,
	}
}

// GenerateMessage implements the MessageGenerator interface.
func (g simpleGenerator) GenerateMessage(
	i arbutil.MessageIndex,
) Message {
	msgData := make([]byte, g.size)
	rand.Read(msgData) // Fill msgData with random bytes
	// We write the index to the message data
	// This can help to identify when debugging issues
	binary.BigEndian.PutUint64(msgData, uint64(i))
	msg := arbostypes.MessageWithMetadataAndBlockInfo{
		MessageWithMeta: arbostypes.MessageWithMetadata{
			Message: &arbostypes.L1IncomingMessage{
				Header: &arbostypes.L1IncomingMessageHeader{
					Kind: arbostypes.L1MessageType_L2Message,
				},
				L2msg: msgData,
			},
		},
	}
	hash := g.hasher.HashMessageWithMetadata(&msg.MessageWithMeta)
	msgResult := &execution.MessageResult{
		BlockHash: hash,
	}
	return Message{
		pos:           i,
		msgWithMeta:   msg.MessageWithMeta,
		msgResult:     *msgResult,
		blockMetadata: nil,
	}
}

// GenerateMessagesFromTo is a function that generates messages from a given
// starting index to an ending index, using the provided MessageGenerator.
//
// This function is meant to be a building block for other message generation
// functions allowing for more control over the range and rate of messages
// generated.
func GenerateMessagesFromTo(ctx context.Context,
	generator MessageGenerator,
	ch chan<- Message,
	from arbutil.MessageIndex,
	to arbutil.MessageIndex,
) {
	for i := from; i < to; i++ {
		msg := generator.GenerateMessage(i)
		select {
		case <-ctx.Done():
			return
		case ch <- msg:
		}
	}
}

// GenerateMessages is a function that is meant to be run in a separate
// goroutine.
// Once launched, it will continuously generate messages and send them
// to the provided channel until the context is done.
//
// The messages are generated with an incrementing index, starting from 0.
// The goroutine will stop when the context is done.
func GenerateMessages(
	ctx context.Context,
	generator MessageGenerator,
	ch chan<- Message,
) {
	defer close(ch)
	GenerateMessagesFromTo(
		ctx,
		generator,
		ch,
		0,
		// Use the maximum value for MessageIndex
		0xFFFFFFFFFFFFFFFF,
	)
}

// GenerateNMessages is a function that is meant to run in a separate goroutine.
// It generates up to the specified number of messages and sends them to the
// provided channel.  The index of each message starts at 0 and will increment
// for each message generated.
//
// When the function exits, the provided channel will be closed.
func GenerateNMessages(
	ctx context.Context,
	generator MessageGenerator,
	ch chan<- Message,
	n int,
) {
	defer close(ch)
	GenerateMessagesFromTo(ctx, generator, ch, 0, arbutil.MessageIndex(n))
}

// WriteMessagesToSequencerAtInterval is a function that is meant to be run in
// a separate goroutine.
//
// At the specified interval, it reads messages from the provided channel
// and writes them to the TransactionStreamer.
func WriteMessagesToSequencerAtInterval(
	ctx context.Context,
	streamer *arbnode.TransactionStreamer,
	ch <-chan Message,
	interval time.Duration,
) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			msg, ok := <-ch
			if !ok {
				// The channel is closed, and no new messages will be incoming.
				return
			}

			if have, want := streamer.WriteMessageFromSequencer(
				msg.pos,
				msg.msgWithMeta,
				msg.msgResult,
				msg.blockMetadata,
			), error(nil); have != want {
				panic(fmt.Sprintf(
					"encountered error while writing message from sequencer:\nhave:\n\t\"%v\"\nwant:\n\t\"%v\"",
					have, want,
				))
			}
		}
	}
}
