// Copyright 2025-2026, Offchain Labs, Inc.
// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE.md

//! Endpoints related to the `ValidationSpawner` Go interface and used by the nitro's validation
//! client.
//! Some of the data structures here are counterparts of Go structs defined in the `validator`
//! package. Their serialization is configured to match the Go side (by using `PascalCase` for
//! field names).

use crate::engine::config::{TARGET_AMD_64, TARGET_ARM_64, TARGET_HOST};
use crate::engine::execution::{validate_continuous, validate_native};
use crate::{config::InputMode, ServerState};
use arbutil::Bytes32;
use axum::extract::State;
use axum::response::IntoResponse;
use axum::Json;
use serde::de::Error;
use serde::Deserialize;
use std::sync::Arc;
use tracing::warn;
use validation::{GoGlobalState, ValidationInput};

pub fn local_target() -> &'static str {
    if cfg!(all(target_os = "linux", target_arch = "aarch64")) {
        TARGET_ARM_64
    } else if cfg!(all(target_os = "linux", target_arch = "x86_64")) {
        TARGET_AMD_64
    } else {
        TARGET_HOST
    }
}

/// Extended validation request that includes both ValidationInput and module_root.
/// This struct allows adding module_root to the request without modifying ValidationInput.
pub struct ValidationRequest {
    pub validation_input: ValidationInput,
    pub module_root: Option<Bytes32>,
}

// Manually deserialize ValidationInput since with 'flatten' serde tries to deserialize
// from the intermediate map generated by serde where keys are all String's which breaks
// the preimage TryFromInto conversion
impl<'de> Deserialize<'de> for ValidationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let v: serde_json::Value = Deserialize::deserialize(deserializer)?;

        // Extract ModuleRoot (equivalent of DisplayFromStr logic)
        let module_root = if let Some(val) = v.get("ModuleRoot") {
            // If the field exists, we strictly require it to be valid
            let s = val
                .as_str()
                .ok_or_else(|| D::Error::custom("ModuleRoot must be a string"))?;

            let mod_root = s.parse::<Bytes32>().map_err(D::Error::custom)?;
            Some(mod_root)
        } else {
            // If the field is missing, log the warning and default to empty
            warn!("Missing module root on validation request.");
            None
        };

        // Deserialize the rest into ValidationInput
        let validation_input: ValidationInput =
            serde_json::from_value(v).map_err(serde::de::Error::custom)?;

        Ok(ValidationRequest {
            validation_input,
            module_root,
        })
    }
}

pub async fn validate(
    State(state): State<Arc<ServerState>>,
    Json(request): Json<ValidationRequest>,
) -> Result<Json<GoGlobalState>, String> {
    match state.mode {
        InputMode::Native => validate_native(&state, request.validation_input).await,
        InputMode::Continuous => validate_continuous(&state, request).await,
    }
}

pub async fn capacity(State(state): State<Arc<ServerState>>) -> impl IntoResponse {
    format!("{:?}", state.available_workers)
}

pub async fn name() -> impl IntoResponse {
    "Rust JIT validator"
}

pub async fn wasm_module_roots(State(state): State<Arc<ServerState>>) -> impl IntoResponse {
    format!("[{:?}]", state.module_root)
}
